
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/shuklarituparn/Filmoteka/api/controllers/actor_controller.go (0.0%)</option>
				
				<option value="file1">github.com/shuklarituparn/Filmoteka/api/controllers/health_controller.go (0.0%)</option>
				
				<option value="file2">github.com/shuklarituparn/Filmoteka/api/controllers/movie_controller.go (0.0%)</option>
				
				<option value="file3">github.com/shuklarituparn/Filmoteka/api/controllers/search_controller.go (0.0%)</option>
				
				<option value="file4">github.com/shuklarituparn/Filmoteka/api/controllers/user_controller.go (0.0%)</option>
				
				<option value="file5">github.com/shuklarituparn/Filmoteka/api/models/actor_model.go (0.0%)</option>
				
				<option value="file6">github.com/shuklarituparn/Filmoteka/api/routes/actor_routes.go (0.0%)</option>
				
				<option value="file7">github.com/shuklarituparn/Filmoteka/api/routes/movie_routes.go (0.0%)</option>
				
				<option value="file8">github.com/shuklarituparn/Filmoteka/api/routes/search_routes.go (0.0%)</option>
				
				<option value="file9">github.com/shuklarituparn/Filmoteka/api/routes/user_routes.go (0.0%)</option>
				
				<option value="file10">github.com/shuklarituparn/Filmoteka/cmd/main/main.go (0.0%)</option>
				
				<option value="file11">github.com/shuklarituparn/Filmoteka/config/database.go (0.0%)</option>
				
				<option value="file12">github.com/shuklarituparn/Filmoteka/docs/docs.go (0.0%)</option>
				
				<option value="file13">github.com/shuklarituparn/Filmoteka/internal/logger/api_logs.go (0.0%)</option>
				
				<option value="file14">github.com/shuklarituparn/Filmoteka/internal/prometheus/metrics.go (0.0%)</option>
				
				<option value="file15">github.com/shuklarituparn/Filmoteka/pkg/common/utils.go (0.0%)</option>
				
				<option value="file16">github.com/shuklarituparn/Filmoteka/pkg/hashing/secure_pass.go (0.0%)</option>
				
				<option value="file17">github.com/shuklarituparn/Filmoteka/pkg/jwt_token/jwt_utils.go (0.0%)</option>
				
				<option value="file18">github.com/shuklarituparn/Filmoteka/pkg/middleware/is_admin.go (0.0%)</option>
				
				<option value="file19">github.com/shuklarituparn/Filmoteka/pkg/middleware/is_authenticated.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package controllers

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "net/http"
        "strconv"
        "strings"

        "github.com/charmbracelet/log"
        "github.com/shuklarituparn/Filmoteka/api/models"
        "github.com/shuklarituparn/Filmoteka/internal/logger"
        "github.com/shuklarituparn/Filmoteka/internal/prometheus"
        "github.com/shuklarituparn/Filmoteka/pkg/common"
        "gorm.io/gorm"
)

var fileLogger = logger.SetupLogger()

// CreateActor creates a new actor.
// @Summary Create a new actor
// @ID create-actor
// @Accept json
// @Produce json
// @Tags Actors
// @Security BearerAuth
// @Param actor body models.CreateActorModel true "Actor object to be created"
// @Success 201 {object} CreateActorResponse "Actor Added"
// @Failure 400 {string} string "Invalid request payload"
// @Failure 500 {string} string "Internal Server Error"
// @Router /api/v1/actors/create [post]
func CreateActor(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.CreateActorApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var actor models.Actor
                if err := json.NewDecoder(r.Body).Decode(&amp;actor); err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid request payload")
                        return
                }</span>
                <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                        err := Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")

                        }</span>
                }(r.Body)
                <span class="cov0" title="0">if !common.ValidateAndRespond(w, actor) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for _, movie := range actor.Movies </span><span class="cov0" title="0">{
                        if !common.ValidateAndRespond(w, movie) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Create(&amp;actor).Error; err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to create actor")
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusCreated)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{"id": actor.ID, "message": "Actor Added"})
                if resErr != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// ReadAllActor returns a list of actors with pagination support.
// @Summary Get all actors with pagination
// @ID read-all-actors
// @Produce json
// @Tags Actors
// @Param page query integer true "Page number"
// @Param page_size query integer true "Number of items per page"
// @Param sort_by query string false "Field to sort by (default birth_date)"
// @Param sort_order query string false "Sort order (ASC or DESC, default DESC)"
// @Success 200 {object} ReadAllActorResponse "List of actors"
// @Failure 400 {string} string "Invalid page_size or page"
// @Failure 500 {string} string "Internal Server Error"
// @Security BearerAuth
// @Router /api/v1/actors/all [get]
func ReadAllActor(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.ReadAllActorApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var actors []models.Actor
                var totalActorsCount int64
                pageSize, err := strconv.Atoi(r.URL.Query().Get("page_size"))
                if err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid page_size")
                        return
                }</span>
                <span class="cov0" title="0">pageNum, err := strconv.Atoi(r.URL.Query().Get("page"))
                if err != nil || pageNum &lt; 1 </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid page")
                        return
                }</span>
                <span class="cov0" title="0">offset := (pageNum - 1) * pageSize
                sortBy := r.URL.Query().Get("sort_by")
                sortOrder := strings.ToUpper(r.URL.Query().Get("sort_order"))
                if sortBy == "" </span><span class="cov0" title="0">{
                        sortBy = "birth_date"
                }</span>
                <span class="cov0" title="0">if sortOrder != "ASC" &amp;&amp; sortOrder != "DESC" </span><span class="cov0" title="0">{
                        sortOrder = "DESC"
                }</span>
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Model(&amp;models.Actor{}).Select("COUNT(*)").Count(&amp;totalActorsCount).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Error counting actors:", err.Error())
                                fileLogger.Println("Error counting actors:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Something went wrong")
                                return err
                        }</span>
                        <span class="cov0" title="0">query := tx.Model(&amp;actors).Limit(pageSize).Offset(offset).Order(fmt.Sprintf("%s %s", sortBy, sortOrder))
                        if err := query.Preload("Movies").Preload("Movies.Actors").Find(&amp;actors).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Error fetching actors:", err.Error())
                                fileLogger.Println("Error fetching actors:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Something went wrong")
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">totalPages := int(math.Ceil(float64(totalActorsCount) / float64(pageSize)))
                w.WriteHeader(http.StatusOK)
                if err := json.NewEncoder(w).Encode(map[string]interface{}{"data": actors, "total_pages": totalPages}); err != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", err.Error())
                        fileLogger.Println("Error encoding JSON:", err.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// ReadActor returns details of a specific actor by ID.
// @Summary Get actor by ID
// @ID read-actor-by-id
// @Produce json
// @Tags Actors
// @Security BearerAuth
// @Param id query string true "Actor ID"
// @Success 200 {object} ReadActorResponse "Actor details"
// @Failure 400 {string} string "Actor ID is required"
// @Failure 404 {string} string "Actor not found"
// @Failure 500 {string} string "Failed to fetch actor"
// @Router /api/v1/actors/get [get]
func ReadActor(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.ReadOneActorApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var actor models.Actor
                actorID := r.URL.Query().Get("id")
                if actorID == "" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Actor ID is required")
                        return
                }</span>
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Preload("Movies").Preload("Movies.Actors").First(&amp;actor, actorID).Error; err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                                        common.ErrorResponse(w, http.StatusNotFound, "Actor not found")
                                        return err
                                }</span>
                                <span class="cov0" title="0">log.Error("Error fetching actor:", err.Error())
                                fileLogger.Println("Error fetching actor:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to fetch actor")
                                return err</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{"data": actor})
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// UpdateActor updates an existing actor.
// @Summary Update an existing actor
// @ID update-actor
// @Accept json
// @Security BearerAuth
// @Produce json
// @Tags Actors
// @Param actor body models.UpdateActorModel true "Actor object to be updated"
// @Success 200 {object} UpdateActorResponse "Actor Updated successfully"
// @Failure 400 {string} string "Invalid request payload"
// @Failure 500 {string} string "Failed to update actor"
// @Router /api/v1/actors/update [put]
func UpdateActor(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.UpdateActorApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var actor models.Actor
                var response models.Actor
                if err := json.NewDecoder(r.Body).Decode(&amp;actor); err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid request payload")
                        return
                }</span>
                <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                        err := Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")

                        }</span>
                }(r.Body)
                <span class="cov0" title="0">if !common.ValidateAndRespond(w, actor) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for _, movie := range actor.Movies </span><span class="cov0" title="0">{
                        if !common.ValidateAndRespond(w, movie) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Session(&amp;gorm.Session{FullSaveAssociations: true}).Where("id = ?", actor.ID).Save(&amp;actor).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Error updating actor:", err.Error())
                                fileLogger.Println("Error updating actor:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to update actor")
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := tx.Preload("Movies").Preload("Movies.Actors").Find(&amp;response, actor.ID).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Error updating actor:", err.Error())
                                fileLogger.Println("Error updating actor:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to update actor")
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{"actor": response, "message": "Actor Updated successfully"})
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// DeleteActor deletes an actor and its associations from the database.
// @Summary Delete an actor
// @ID delete-actor
// @Produce json
// @Tags Actors
// @Security BearerAuth
// @Param id query string true "Actor ID"
// @Success 200 {object} DeleteActorResponse "Actor deleted successfully"
// @Failure 400 {string} string "Actor ID is required"
// @Failure 500 {string} string "Failed to delete actor or its associations"
// @Router /api/v1/actors/delete [delete]
func DeleteActor(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.DeleteActorApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                actorID := r.URL.Query().Get("id")
                if actorID == "" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Actor ID is required")
                        return
                }</span>
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Exec("DELETE FROM actor_movies WHERE actor_id = ?", actorID).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Error deleting association:", err.Error())
                                fileLogger.Println("Error deleting association:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to delete Association")
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := tx.Delete(&amp;models.Actor{}, actorID).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Error deleting actor:", err.Error())
                                fileLogger.Println("Error deleting actor:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to delete actor")
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "message": "Actor deleted successfully",
                })
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// PatchActor updates an existing actor with the provided patch data.
// @Summary Update an existing actor partially
// @ID patch-actor
// @Accept json
// @Security BearerAuth
// @Produce json
// @Tags Actors
// @Param id query string true "Actor ID"
// @Param patchData body models.CreateActorModel true "Patch data for updating the actor"
// @Success 200 {object} PatchActorResponse "Actor updated successfully"
// @Failure 400 {string} string "Invalid request payload"
// @Failure 500 {string} string "Failed to update actor or its associations"
// @Router /api/v1/actors/patch [patch]
func PatchActor(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.PatchActorApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var patchData map[string]interface{}
                if err := json.NewDecoder(r.Body).Decode(&amp;patchData); err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid request payload")
                        return
                }</span>
                <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                        err := Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")

                        }</span>
                }(r.Body)
                <span class="cov0" title="0">actorID := r.URL.Query().Get("id")
                if actorID == "" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Actor ID is required")
                        return
                }</span>
                <span class="cov0" title="0">movies, ok := patchData["movies"].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Movies data is missing or invalid")
                        return
                }</span>
                <span class="cov0" title="0">delete(patchData, "movies")
                txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        for _, movie := range movies </span><span class="cov0" title="0">{
                                movieMap, ok := movie.(map[string]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        return errors.ErrUnsupported
                                }</span>
                                <span class="cov0" title="0">if err := tx.Model(&amp;models.Movie{}).Where("id=?", movieMap["id"]).Updates(movieMap).Error; err != nil </span><span class="cov0" title="0">{
                                        log.Error("Error updating movie:", err.Error())
                                        fileLogger.Println("Error updating movie:", err.Error())
                                        return err
                                }</span>
                                <span class="cov0" title="0">query := "SELECT COUNT(*) FROM actor_movies WHERE actor_id = ? AND movie_id = ?"
                                var count int64
                                if err := tx.Raw(query, actorID, movieMap["id"]).Row().Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                                        log.Error("Error counting actor-movie relationship:", err.Error())
                                        fileLogger.Println("Error counting actor-movie relationship:", err.Error())
                                        return err
                                }</span>
                                <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                                        query := "INSERT INTO actor_movies (actor_id, movie_id) VALUES (?, ?)"
                                        if err := tx.Exec(query, actorID, movieMap["id"]).Error; err != nil </span><span class="cov0" title="0">{
                                                log.Error("Error inserting actor-movie relationship:", err.Error())
                                                fileLogger.Println("Error inserting actor-movie relationship:", err.Error())
                                                return err
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if err := tx.Model(&amp;models.Actor{}).Where("id = ?", actorID).Updates(patchData).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Error updating actor:", err.Error())
                                fileLogger.Println("Error updating actor:", err.Error())
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "message": "Actor updated successfully",
                })
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controllers

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/charmbracelet/log"
)

// HealthCheck performs a health check and returns the status of the application.
// @Summary Perform health check
// @Tags Healthcheck
// @ID health-check
// @Produce json
// @Success 200 {object} HealthCheckResponse "Health check response"
// @Router /healthcheck [get]
func HealthCheck(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        response := HealthCheckResponse{
                Author:      "Rituparn Shukla",
                CurrentTime: time.Now(),
                Status:      "up",
        }
        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                log.Error("Error encoding JSON:", err.Error())
                fileLogger.Println("Error encoding JSON:", err.Error())
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controllers

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math"
        "net/http"
        "strconv"
        "strings"

        "github.com/charmbracelet/log"
        "github.com/shuklarituparn/Filmoteka/api/models"
        "github.com/shuklarituparn/Filmoteka/internal/prometheus"
        "github.com/shuklarituparn/Filmoteka/pkg/common"
        "gorm.io/gorm"
)

// CreateMovie creates a new movie.
// @Summary Create a new movie
// @ID create-movie
// @Security BearerAuth
// @Accept json
// @Produce json
// @Tags Movies
// @Param movie body models.CreateMovieModel true "Movie object to be created"
// @Success 201 {object} CreateMovieResponse "Movie created successfully"
// @Failure 400 {string} string "Invalid request payload"
// @Failure 500 {string} string "Internal Server Error"
// @Router /api/v1/movies/create [post]
func CreateMovie(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.CreateMovieApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var movie models.Movie
                if err := json.NewDecoder(r.Body).Decode(&amp;movie); err != nil </span><span class="cov0" title="0">{
                        log.Error("Invalid request payload:", err.Error())
                        fileLogger.Println("Invalid request payload:", err.Error())
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid request payload")
                        return
                }</span>
                <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                        err := Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")

                        }</span>
                }(r.Body)
                <span class="cov0" title="0">if !common.ValidateAndRespond(w, movie) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for _, actor := range movie.Actors </span><span class="cov0" title="0">{
                        if !common.ValidateAndRespond(w, actor) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Create(&amp;movie).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Failed to create movie:", err.Error())
                                fileLogger.Println("Failed to create movie:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, fmt.Sprintf("%v", err.Error()))
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusCreated)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "message": "Movie created successfully",
                        "data":    movie,
                })
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// ReadAllMovies returns a list of movies with pagination support.
// @Summary Get all movies with pagination
// @ID read-all-movies
// @Produce json
// @Security BearerAuth
// @Tags Movies
// @Param page query integer true "Page number"
// @Param page_size query integer true "Number of items per page"
// @Param sort_by query string false "Field to sort by (default rating)"
// @Param sort_order query string false "Sort order (ASC or DESC, default DESC)"
// @Success 200 {object} ReadAllMoviesResponse "List of movies"
// @Failure 400 {string} string "Invalid page_size or page"
// @Failure 500 {string} string "Internal Server Error"
// @Router /api/v1/movies/all [get]
func ReadAllMovies(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.ReadAllMovieApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var totalMoviesCount int64
                var movies []models.Movie
                pageSize, err := strconv.Atoi(r.URL.Query().Get("page_size"))
                if err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid page_size")
                        return
                }</span>
                <span class="cov0" title="0">pageNum, err := strconv.Atoi(r.URL.Query().Get("page"))
                if err != nil || pageNum &lt; 1 </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid page")
                        return
                }</span>
                <span class="cov0" title="0">offset := (pageNum - 1) * pageSize
                sortBy := r.URL.Query().Get("sort_by")
                sortOrder := strings.ToUpper(r.URL.Query().Get("sort_order"))
                if sortBy == "" </span><span class="cov0" title="0">{
                        sortBy = "rating"
                }</span>
                <span class="cov0" title="0">if sortOrder != "ASC" &amp;&amp; sortOrder != "DESC" </span><span class="cov0" title="0">{
                        sortOrder = "DESC"
                }</span>
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        query := db.Model(&amp;movies).Limit(pageSize).Offset(offset).Order(fmt.Sprintf("%s %s", sortBy, sortOrder))
                        if err := query.Preload("Actors").Preload("Actors.Movies").Find(&amp;movies).Error; err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Something went wrong")
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := tx.Model(&amp;models.Movie{}).Select("COUNT(*)").Count(&amp;totalMoviesCount).Error; err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Something went wrong")
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">totalPages := int(math.Ceil(float64(totalMoviesCount) / float64(pageSize)))
                w.WriteHeader(http.StatusOK)
                response := map[string]interface{}{
                        "data":        movies,
                        "total_pages": totalPages,
                }
                if err := json.NewEncoder(w).Encode(response); err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// ReadMovie returns details of a specific movie by ID.
// @Summary Get movie by ID
// @ID read-movie-by-id
// @Produce json
// @Tags Movies
// @Security BearerAuth
// @Param id query string true "Movie ID"
// @Success 200 {object} ReadMovieResponse "Movie details"
// @Failure 400 {string} string "Movie ID is required"
// @Failure 404 {string} string "Movie not found"
// @Failure 500 {string} string "Failed to fetch movie"
// @Router /api/v1/movies/get [get]
func ReadMovie(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.ReadOneMovieApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var movie models.Movie
                movieID := r.URL.Query().Get("id")
                if movieID == "" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Movie ID is required")
                        return
                }</span>
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Preload("Actors").Preload("Actors.Movies").First(&amp;movie, movieID).Error; err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                                        common.ErrorResponse(w, http.StatusNotFound, "Movie not found")
                                        return err
                                }</span>
                                <span class="cov0" title="0">log.Error("Error fetching movie:", err.Error())
                                fileLogger.Println("Error fetching movie:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                                return err</span>
                        }
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "data": movie,
                })
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// UpdateMovie updates an existing movie.
// @Summary Update an existing movie
// @ID update-movie
// @Accept json
// @Tags Movies
// @Produce json
// @Security BearerAuth
// @Param movie body models.UpdateMovieModel true "Movie object to be updated"
// @Success 200 {object} UpdateMovieResponse "Movie updated successfully"
// @Failure 400 {string} string "Invalid request payload"
// @Failure 500 {string} string "Failed to update movie"
// @Router /api/v1/movies/update [put]
func UpdateMovie(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.UpdateMovieApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var movie models.Movie
                var response models.Movie
                if err := json.NewDecoder(r.Body).Decode(&amp;movie); err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid request payload")
                        return
                }</span>
                <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                        err := Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")

                        }</span>
                }(r.Body)
                <span class="cov0" title="0">if !common.ValidateAndRespond(w, movie) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">for _, actor := range movie.Actors </span><span class="cov0" title="0">{
                        if !common.ValidateAndRespond(w, actor) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Session(&amp;gorm.Session{FullSaveAssociations: true}).Where("id = ?", movie.ID).Save(&amp;movie).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Failed to update movie:", err.Error())
                                fileLogger.Println("Failed to update movie:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to update movie")
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := tx.Preload("Actors").Preload("Actors.Movies").Find(&amp;response, movie.ID).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Failed to update movie:", err.Error())
                                fileLogger.Println("Failed to update movie:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to update movie")
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "message": "Movie updated successfully",
                        "data":    response,
                })
                if resErr != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// DeleteMovie deletes a movie and its associations from the database.
// @Summary Delete a movie
// @ID delete-movie
// @Tags Movies
// @Security BearerAuth
// @Produce json
// @Param id query string true "Movie ID"
// @Success 200 {object} DeleteMovieResponse "Movie deleted successfully"
// @Failure 400 {string} string "Movie ID is required"
// @Failure 500 {string} string "Failed to delete movie or its associations"
// @Router /api/v1/movies/delete [delete]
func DeleteMovie(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.DeleteMovieApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                movieID := r.URL.Query().Get("id")
                if movieID == "" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Movie ID is required")
                        return
                }</span>
                <span class="cov0" title="0">txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        if err := tx.Exec("DELETE FROM actor_movies WHERE movie_id = ?", movieID).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Failed to delete Association:", err.Error())
                                fileLogger.Println("Failed to delete Association:", err.Error())
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to delete Association")
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := tx.Delete(&amp;models.Movie{}, movieID).Error; err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to delete movie")
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "message": "Movie deleted successfully",
                })
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// PatchMovie updates an existing movie with the provided patch data.
// @Summary Update an existing movie partially
// @ID patch-movie
// @Accept json
// @Tags Movies
// @Produce json
// @Security BearerAuth
// @Param id query string true "Movie ID"
// @Param patchData body models.CreateMovieModel true "Patch data for updating the movie"
// @Success 200 {object} PatchMovieResponse "Movie updated successfully"
// @Failure 400 {string} string "Invalid request payload"
// @Failure 500 {string} string "Failed to update movie or its associations"
// @Router /api/v1/movies/patch [patch]
func PatchMovie(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                prometheus.PatchMovieApiPingCounter.Inc()
                w.Header().Set("Content-Type", "application/json")
                var patchData map[string]interface{}
                if err := json.NewDecoder(r.Body).Decode(&amp;patchData); err != nil </span><span class="cov0" title="0">{
                        log.Error("Invalid request payload:", err.Error())
                        fileLogger.Println("Invalid request payload:", err.Error())
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid request payload")
                        return
                }</span>
                <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                        err := Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")

                        }</span>
                }(r.Body)
                <span class="cov0" title="0">movieID := r.URL.Query().Get("id")
                if movieID == "" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Movie ID is required")
                        return
                }</span>
                <span class="cov0" title="0">actors, ok := patchData["actors"].([]interface{})
                if !ok </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Actors data is missing or invalid")
                        return
                }</span>
                <span class="cov0" title="0">delete(patchData, "actors")
                txErr := db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                        for _, actor := range actors </span><span class="cov0" title="0">{
                                actorMap, ok := actor.(map[string]interface{})
                                if !ok </span><span class="cov0" title="0">{
                                        return errors.ErrUnsupported
                                }</span>
                                <span class="cov0" title="0">if err := tx.Model(&amp;models.Actor{}).Where("id=?", actorMap["id"]).Updates(actorMap).Error; err != nil </span><span class="cov0" title="0">{
                                        log.Error("Error updating actor:", err.Error())
                                        fileLogger.Println("Error updating actor:", err.Error())
                                        return err
                                }</span>
                                <span class="cov0" title="0">query := "SELECT COUNT(*) FROM actor_movies WHERE actor_id = ? AND movie_id = ?"
                                var count int64
                                if err := tx.Raw(query, actorMap["id"], movieID).Row().Scan(&amp;count); err != nil </span><span class="cov0" title="0">{
                                        log.Error("Error counting actor-movie relationship:", err.Error())
                                        fileLogger.Println("Error counting actor-movie relationship:", err.Error())
                                        return err
                                }</span>

                                <span class="cov0" title="0">if count == 0 </span><span class="cov0" title="0">{
                                        query := "INSERT INTO actor_movies (actor_id, movie_id) VALUES (?, ?)"
                                        if err := tx.Exec(query, actorMap["id"], movieID).Error; err != nil </span><span class="cov0" title="0">{
                                                log.Error("Error inserting actor-movie relationship:", err.Error())
                                                fileLogger.Println("Error inserting actor-movie relationship:", err.Error())
                                                return err
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if err := tx.Session(&amp;gorm.Session{FullSaveAssociations: true}).Model(&amp;models.Movie{}).Where("id = ?", movieID).Updates(patchData).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Error updating actor:", err.Error())
                                fileLogger.Println("Error updating actor:", err.Error())
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if txErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">resErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "message": "Movie updated successfully",
                })
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controllers

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/charmbracelet/log"
        "github.com/shuklarituparn/Filmoteka/api/models"
        "github.com/shuklarituparn/Filmoteka/pkg/common"
        "gorm.io/gorm"
)

// SearchMovie searches for movies based on the provided query string.
// @Summary Search for movies
// @ID search-movies
// @Produce json
// @Tags Search Movies
// @Security BearerAuth
// @Param q query string true "Search query"
// @Param sort_by query string false "Field to sort by (default rating)"
// @Param sort_order query string false "Sort order (ASC or DESC, default DESC)"
// @Success 200 {object} SearchMovieResponse "List of matching movies"
// @Failure 400 {string} string "Invalid search query"
// @Failure 500 {string} string "Error encoding response"
// @Router /api/v1/search [get]
func SearchMovie(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")
                query := r.URL.Query().Get("q")
                sortBy := r.URL.Query().Get("sort_by")
                sortOrder := strings.ToUpper(r.URL.Query().Get("sort_order"))
                if sortBy == "" </span><span class="cov0" title="0">{
                        sortBy = "rating"
                }</span>
                <span class="cov0" title="0">if sortOrder != "ASC" &amp;&amp; sortOrder != "DESC" </span><span class="cov0" title="0">{
                        sortOrder = "DESC"
                }</span>
                <span class="cov0" title="0">if query == "" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid search query")
                        return
                }</span>
                <span class="cov0" title="0">searchQuery := "%" + strings.TrimSpace(query) + "%"

                var movies []models.Movie
                db.Model(&amp;models.Movie{}).
                        Joins("JOIN actor_movies ON movies.id = actor_movies.movie_id").
                        Joins("JOIN actors ON actors.id = actor_movies.actor_id").
                        Where("LOWER(title) LIKE ? OR LOWER(first_name) LIKE ? OR LOWER(last_name) LIKE ?", "%"+strings.ToLower(searchQuery)+"%", "%"+strings.ToLower(searchQuery)+"%", "%"+strings.ToLower(searchQuery)+"%").
                        Order(fmt.Sprintf("%s %s", sortBy, sortOrder)).
                        Preload("Actors").Preload("Actors.Movies").
                        Distinct().
                        Find(&amp;movies)
                if err := json.NewEncoder(w).Encode(map[string]interface{}{"data": movies}); err != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding response:", err.Error())
                        fileLogger.Println("Error encoding response:", err.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Error encoding response")
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package controllers

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"

        "github.com/charmbracelet/log"
        "github.com/go-playground/validator"
        "github.com/shuklarituparn/Filmoteka/api/models"
        "github.com/shuklarituparn/Filmoteka/pkg/common"
        "github.com/shuklarituparn/Filmoteka/pkg/hashing"
        jwt "github.com/shuklarituparn/Filmoteka/pkg/jwt_token"
        "gorm.io/gorm"
)

// RegisterUser handles user registration.
// @Summary Register a new user
// @Description Register a new user with email and password
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body models.RegisterUserModel true "User information"
// @Success 201 {object} CreateUserResponse "User Created Successfully"
// @Failure 400 {object} ErrorResponse "Invalid request payload"
// @Failure 500 {object} ErrorResponse "Internal Server Error"
// @Router /api/v1/users/register [post]
func RegisterUser(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                fileLogger.Println("Request received:", r.Method, r.URL.Path)
                w.Header().Set("Content-Type", "application/json")
                var user models.User
                if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                        log.Error("Error decoding JSON:", err.Error())
                        fileLogger.Println("Error decoding JSON:", err.Error())
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid request payload")
                        return
                }</span>
                <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                        err := Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")

                        }</span>
                }(r.Body)
                <span class="cov0" title="0">user.Role = "USER"
                validate := validator.New()
                if err := validate.Struct(user); err != nil </span><span class="cov0" title="0">{
                        errorsMap := make(map[string]string)
                        for _, e := range err.(validator.ValidationErrors) </span><span class="cov0" title="0">{
                                errorsMap[e.Field()] = e.Tag()
                        }</span>
                        <span class="cov0" title="0">errJSON, _ := json.Marshal(errorsMap)
                        common.ErrorResponse(w, http.StatusBadRequest, string(errJSON))
                        return</span>
                }
                <span class="cov0" title="0">hashedPassword, err := hashing.HashPassword(user.Password)
                if err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusInternalServerError, "Failed to hash password")
                        return
                }</span>
                <span class="cov0" title="0">user.Password = hashedPassword
                if err := db.Model(&amp;models.User{}).Create(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                        log.Error("Error creating user:", err.Error())
                        fileLogger.Println("Error creating user:", err.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, fmt.Sprintf("Failed to register user %v", err.Error()))
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusCreated)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "id":      user.ID,
                        "message": "User Created Successfully",
                        "email":   user.Email,
                        "role":    user.Role,
                })
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// LoginUser handles user login.
// @Summary Log in a user
// @Description Log in a user with email and password
// @Tags Authentication
// @Accept json
// @Produce json
// @Param request body models.LoginUserModel true "User credentials"
// @Success 200 {object} LoginResponse "Logged In Successfully"
// @Failure 400 {object} ErrorResponse "Invalid request payload"
// @Failure 401 {object} ErrorResponse "Invalid email or password"
// @Failure 500 {object} ErrorResponse "Internal Server Error"
// @Router /api/v1/users/login [post]
func LoginUser(db *gorm.DB) http.HandlerFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                fileLogger.Println("Request received:", r.Method, r.URL.Path)
                w.Header().Set("Content-Type", "application/json")
                var user models.User
                if err := json.NewDecoder(r.Body).Decode(&amp;user); err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid request payload")
                        return
                }</span>
                <span class="cov0" title="0">defer func(Body io.ReadCloser) </span><span class="cov0" title="0">{
                        err := Body.Close()
                        if err != nil </span><span class="cov0" title="0">{
                                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")

                        }</span>
                }(r.Body)
                <span class="cov0" title="0">var storedUser models.User
                if err := db.Model(&amp;models.User{}).Where("email = ?", user.Email).First(&amp;storedUser).Error; err != nil </span><span class="cov0" title="0">{
                        log.Error("Error finding user:", err.Error())
                        fileLogger.Println("Error finding user:", err.Error())
                        common.ErrorResponse(w, http.StatusUnauthorized, "Invalid email or password")
                        return
                }</span>
                <span class="cov0" title="0">if ok := hashing.CheckPasswordHash(user.Password, storedUser.Password); !ok </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusUnauthorized, "Invalid email or password")
                        return
                }</span>
                <span class="cov0" title="0">token, _ := jwt.GetJWTToken(user.Email, storedUser.Role, 1)
                refresh, err := jwt.GetJWTToken(user.Email, storedUser.Role, 5)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Error generating token:", err.Error())
                        fileLogger.Println("Error generating token:", err.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, err.Error())
                        return
                }</span>
                <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
                resErr := json.NewEncoder(w).Encode(map[string]interface{}{
                        "id":            storedUser.ID,
                        "message":       "Logged In Successfully",
                        "email":         storedUser.Email,
                        "role":          storedUser.Role,
                        "access_token":  token,
                        "refresh_token": refresh,
                })
                if resErr != nil </span><span class="cov0" title="0">{
                        log.Error("Error encoding JSON:", resErr.Error())
                        fileLogger.Println("Error encoding JSON:", resErr.Error())
                        common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
                }</span>
        }
}

// RefreshToken handles refreshing JWT tokens.
// @Summary Refresh JWT tokens
// @Description Refresh JWT access and refresh tokens
// @Tags Authentication
// @Accept json
// @Security BearerAuth
// @Produce json
// @Success 200 {object} RefreshTokenResponse "New access and refresh tokens"
// @Failure 400 {object} ErrorResponse "Invalid or expired token"
// @Failure 500 {object} ErrorResponse "Internal Server Error"
// @Router /api/v1/users/refresh [get]
func RefreshToken(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        fileLogger.Println("Request received:", r.Method, r.URL.Path)
        tokenString := strings.Split(r.Header.Get("Authorization"), " ")[1]
        if tokenString == "" </span><span class="cov0" title="0">{
                common.ErrorResponse(w, http.StatusBadRequest, "Please supply Token")
        }</span>
        <span class="cov0" title="0">claims, err := jwt.VerifyToken(tokenString)
        if err != nil </span><span class="cov0" title="0">{
                common.ErrorResponse(w, http.StatusUnauthorized, "Invalid or expired token")
                return
        }</span>
        <span class="cov0" title="0">newToken, _ := jwt.GetJWTToken(claims.Email, claims.Role, 1)
        refresh, err := jwt.GetJWTToken(claims.Email, claims.Role, 5)

        if err != nil </span><span class="cov0" title="0">{
                log.Error("Error generating new token:", err.Error())
                fileLogger.Println("Error generating new token:", err.Error())
                common.ErrorResponse(w, http.StatusInternalServerError, "Failed to generate new token")
                return
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        resErr := json.NewEncoder(w).Encode(map[string]string{"token": newToken, "refresh": refresh})
        if resErr != nil </span><span class="cov0" title="0">{
                log.Error("Error encoding JSON:", resErr.Error())
                fileLogger.Println("Error encoding JSON:", resErr.Error())
                common.ErrorResponse(w, http.StatusInternalServerError, "Internal Server Error")
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package models

import (
        "time"

        "github.com/go-playground/validator"
)

type Actor struct {
        ID        uint    `gorm:"primaryKey" json:"id"`
        FirstName string  `gorm:"size:100;not null" json:"first_name" validate:"required,max=100"`
        LastName  string  `gorm:"size:100;not null" json:"last_name" validate:"required,max=100"`
        Gender    string  `json:"gender" validate:"required"`
        BirthDate string  `gorm:"not null" json:"birth_date" validate:"required,validDate"`
        Movies    []Movie `gorm:"many2many:actor_movies;" json:"movies,omitempty"`
}

type CreateActorModel struct {
        FirstName string  `json:"first_name" validate:"required,max=100"`
        LastName  string  `json:"last_name" validate:"required,max=100"`
        Gender    string  `json:"gender" validate:"required"`
        BirthDate string  `json:"birth_date" validate:"required,validDate"`
        Movies    []Movie `json:"movies"`
}

type UpdateActorModel struct {
        CreateActorModel
        ID uint `json:"id" validate:"required"`
}

func ValidDate(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        dateStr := fl.Field().String()
        _, err := time.Parse("2006-01-02", dateStr)
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package routes

import (
        "net/http"

        "github.com/shuklarituparn/Filmoteka/api/controllers"
        "github.com/shuklarituparn/Filmoteka/config"
        "github.com/shuklarituparn/Filmoteka/pkg/middleware"
)

func ActorRouter(mux *http.ServeMux) <span class="cov0" title="0">{
        const prefix = "/api/v1/actors"

        getActor := prefix + "/get"
        mux.Handle(getActor, middleware.IsAuthenticated(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodGet </span><span class="cov0" title="0">{
                        controllers.ReadActor(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">allActors := prefix + "/all"
        mux.Handle(allActors, middleware.IsAuthenticated(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodGet </span><span class="cov0" title="0">{
                        controllers.ReadAllActor(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">updateRoute := prefix + "/update"
        mux.Handle(updateRoute, middleware.IsAdmin(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodPut </span><span class="cov0" title="0">{
                        controllers.UpdateActor(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">patchRoute := prefix + "/patch"
        mux.Handle(patchRoute, middleware.IsAdmin(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodPatch </span><span class="cov0" title="0">{
                        controllers.PatchActor(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">deleteRoute := prefix + "/delete"
        mux.Handle(deleteRoute, middleware.IsAdmin(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodDelete </span><span class="cov0" title="0">{
                        controllers.DeleteActor(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">createRoute := prefix + "/create"
        mux.Handle(createRoute, middleware.IsAdmin(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                        controllers.CreateActor(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package routes

import (
        "net/http"

        "github.com/shuklarituparn/Filmoteka/api/controllers"
        "github.com/shuklarituparn/Filmoteka/config"
        "github.com/shuklarituparn/Filmoteka/pkg/middleware"
)

func MovieRouter(mux *http.ServeMux) <span class="cov0" title="0">{
        const prefix = "/api/v1/movies"

        getMovie := prefix + "/get"
        mux.Handle(getMovie, middleware.IsAuthenticated(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodGet </span><span class="cov0" title="0">{
                        controllers.ReadMovie(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">allMovies := prefix + "/all"
        mux.Handle(allMovies, middleware.IsAuthenticated(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodGet </span><span class="cov0" title="0">{
                        controllers.ReadAllMovies(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">createRoute := prefix + "/create"
        mux.Handle(createRoute, middleware.IsAdmin(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                        controllers.CreateMovie(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">updateRoute := prefix + "/update"
        mux.Handle(updateRoute, middleware.IsAdmin(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodPut </span><span class="cov0" title="0">{
                        controllers.UpdateMovie(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">patchRoute := prefix + "/patch"
        mux.Handle(patchRoute, middleware.IsAdmin(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodPatch </span><span class="cov0" title="0">{
                        controllers.PatchMovie(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))

        <span class="cov0" title="0">deleteRoute := prefix + "/delete"
        mux.Handle(deleteRoute, middleware.IsAdmin(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodDelete </span><span class="cov0" title="0">{
                        controllers.DeleteMovie(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package routes

import (
        "net/http"

        "github.com/shuklarituparn/Filmoteka/api/controllers"
        "github.com/shuklarituparn/Filmoteka/config"
        "github.com/shuklarituparn/Filmoteka/pkg/middleware"
)

func SearchRouter(mux *http.ServeMux) <span class="cov0" title="0">{
        const prefix = "/api/v1/search"

        mux.Handle(prefix, middleware.IsAuthenticated(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodGet </span><span class="cov0" title="0">{
                        controllers.SearchMovie(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package routes

import (
        "net/http"

        "github.com/shuklarituparn/Filmoteka/api/controllers"
        "github.com/shuklarituparn/Filmoteka/config"
        "github.com/shuklarituparn/Filmoteka/pkg/middleware"
)

func UserRouter(mux *http.ServeMux) <span class="cov0" title="0">{
        const prefix = "/api/v1/users"
        registerRoute := prefix + "/register"
        loginRoute := prefix + "/login"
        refreshTokenRoute := prefix + "/refresh"

        mux.Handle(registerRoute, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                        controllers.RegisterUser(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        }))

        <span class="cov0" title="0">mux.Handle(loginRoute, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                        controllers.LoginUser(config.GetInstance())(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        }))

        <span class="cov0" title="0">mux.Handle(refreshTokenRoute, middleware.IsAuthenticated(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.Method == http.MethodGet </span><span class="cov0" title="0">{
                        controllers.RefreshToken(w, r)
                }</span> else<span class="cov0" title="0"> {
                        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
                }</span>
        })))
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "fmt"
        "net/http"
        "os"
        "strconv"

        "github.com/charmbracelet/log"
        "github.com/joho/godotenv"
        "github.com/shuklarituparn/Filmoteka/api/controllers"
        "github.com/shuklarituparn/Filmoteka/api/routes"
        "github.com/shuklarituparn/Filmoteka/config"
        "github.com/shuklarituparn/Filmoteka/internal/logger"
        "github.com/shuklarituparn/Filmoteka/internal/prometheus"
        httpSwagger "github.com/swaggo/http-swagger"
)

// @title Filmotek API
// @version 1.0
// @description Fimotek Api Docs
// @contact.name API Support
// @contact.url https://github.com/shuklarituparn
// @contact.email rtprnshukla@gmail.com
// @license.name MIT
// @license.url https://opensource.org/licenses/MIT
// @host localhost:8080
// @BasePath /
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func main() <span class="cov0" title="0">{
        prometheus.Init()

        err := godotenv.Load()

        var fileLogger = logger.SetupLogger()

        if err != nil </span><span class="cov0" title="0">{
                log.Error("Error loading .env file")
                fileLogger.Println("Error loading .env file")
        }</span>

        <span class="cov0" title="0">config.ConnectDb()

        if os.Getenv("PORT") == "" </span><span class="cov0" title="0">{
                log.Error("PORT environment variable not set")
                fileLogger.Println("PORT environment variable not set")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">ServerPort, _ := strconv.Atoi(os.Getenv("PORT"))

        port := ServerPort

        rootMux := http.NewServeMux()
        rootMux.Handle("/swagger.json", http.FileServer(http.Dir("./docs")))
        rootMux.HandleFunc("/healthcheck", controllers.HealthCheck)
        routes.ActorRouter(rootMux)
        routes.MovieRouter(rootMux)
        routes.UserRouter(rootMux)
        routes.SearchRouter(rootMux)
        rootMux.HandleFunc("/docs/*", httpSwagger.Handler(
                httpSwagger.URL("/swagger.json"),
        ))
        log.Info(fmt.Sprintf("Server started on port %d", port))
        fileLogger.Printf("Server started on port %d", port)

        serverError := http.ListenAndServe(fmt.Sprintf(":%d", port), rootMux)
        if serverError != nil </span><span class="cov0" title="0">{
                log.Error("Something went wrong while starting the server!")
                fileLogger.Println("Something went wrong while starting the server!")
                panic(serverError)</span>
        } else<span class="cov0" title="0"> {
                log.Info("Server started successfully!")
                fileLogger.Println("Server started successfully!")
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package config

import (
        "fmt"
        "github.com/pkg/errors"
        "os"
        "strconv"

        "github.com/charmbracelet/log"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        _ "github.com/lib/pq"
        "github.com/shuklarituparn/Filmoteka/api/models"
        "github.com/shuklarituparn/Filmoteka/internal/logger"
        "github.com/shuklarituparn/Filmoteka/pkg/hashing"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

var db *gorm.DB

func GetInstance() *gorm.DB <span class="cov0" title="0">{
        return db
}</span>

func ConnectDb() <span class="cov0" title="0">{
        var fileLogger = logger.SetupLogger()

        var (
                host     = os.Getenv("POSTGRES_HOST")
                port     = os.Getenv("POSTGRES_PORT")
                user     = os.Getenv("POSTGRES_USER")
                password = os.Getenv("POSTGRES_PASSWORD")
                dbname   = os.Getenv("POSTGRES_DB")
        )
        portInt, _ := strconv.Atoi(port)
        psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+
                "password=%s dbname=%s sslmode=disable",
                host, portInt, user, password, dbname)

        postgresqlDb, err := gorm.Open(postgres.Open(psqlInfo), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Error connecting to the database:", err)
                fileLogger.Println("Error connecting to the database:", err)
        }</span>
        <span class="cov0" title="0">migrationErr := postgresqlDb.AutoMigrate(&amp;models.Actor{}, &amp;models.User{}, &amp;models.Movie{})
        if migrationErr != nil </span><span class="cov0" title="0">{
                log.Error(migrationErr)
                fileLogger.Println(migrationErr)
        }</span>
        <span class="cov0" title="0">var adminUser models.User
        adminPassword, _ := hashing.HashPassword("adminpassword")
        if result := postgresqlDb.First(&amp;adminUser, "role = ?", "ADMIN"); result.Error != nil </span><span class="cov0" title="0">{
                if errors.Is(result.Error, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        admin := models.User{
                                Email:    "admin@example.com",
                                Password: adminPassword,
                                Role:     "ADMIN",
                        }
                        if err := postgresqlDb.Create(&amp;admin).Error; err != nil </span><span class="cov0" title="0">{
                                log.Error("Error creating admin user:", err)
                                fileLogger.Println("Error creating admin user:", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Error("Error querying admin user:", result.Error)
                        fileLogger.Println("Error querying admin user:", result.Error)
                }</span>
        }
        <span class="cov0" title="0">db = postgresqlDb
        log.Info("Successfully connected!")
        fileLogger.Println("Successfully connected to the database!")</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package docs GENERATED BY SWAG; DO NOT EDIT
// This file was generated by swaggo/swag
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "API Support",
            "url": "https://github.com/shuklarituparn",
            "email": "rtprnshukla@gmail.com"
        },
        "license": {
            "name": "MIT",
            "url": "https://opensource.org/licenses/MIT"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/api/v1/actors/all": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Actors"
                ],
                "summary": "Get all actors with pagination",
                "operationId": "read-all-actors",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Page number",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Field to sort by (default birth_date)",
                        "name": "sort_by",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order (ASC or DESC, default DESC)",
                        "name": "sort_order",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of actors",
                        "schema": {
                            "$ref": "#/definitions/controllers.ReadAllActorResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid page_size or page",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/actors/create": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Actors"
                ],
                "summary": "Create a new actor",
                "operationId": "create-actor",
                "parameters": [
                    {
                        "description": "Actor object to be created",
                        "name": "actor",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateActorModel"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Actor Added",
                        "schema": {
                            "$ref": "#/definitions/controllers.CreateActorResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request payload",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/actors/delete": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Actors"
                ],
                "summary": "Delete an actor",
                "operationId": "delete-actor",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Actor ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Actor deleted successfully",
                        "schema": {
                            "$ref": "#/definitions/controllers.DeleteActorResponse"
                        }
                    },
                    "400": {
                        "description": "Actor ID is required",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Failed to delete actor or its associations",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/actors/get": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Actors"
                ],
                "summary": "Get actor by ID",
                "operationId": "read-actor-by-id",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Actor ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Actor details",
                        "schema": {
                            "$ref": "#/definitions/controllers.ReadActorResponse"
                        }
                    },
                    "400": {
                        "description": "Actor ID is required",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "404": {
                        "description": "Actor not found",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Failed to fetch actor",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/actors/patch": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Actors"
                ],
                "summary": "Update an existing actor partially",
                "operationId": "patch-actor",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Actor ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "description": "Patch data for updating the actor",
                        "name": "patchData",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateActorModel"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Actor updated successfully",
                        "schema": {
                            "$ref": "#/definitions/controllers.PatchActorResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request payload",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Failed to update actor or its associations",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/actors/update": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Actors"
                ],
                "summary": "Update an existing actor",
                "operationId": "update-actor",
                "parameters": [
                    {
                        "description": "Actor object to be updated",
                        "name": "actor",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateActorModel"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Actor Updated successfully",
                        "schema": {
                            "$ref": "#/definitions/controllers.UpdateActorResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request payload",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Failed to update actor",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/movies/all": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Movies"
                ],
                "summary": "Get all movies with pagination",
                "operationId": "read-all-movies",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Page number",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Number of items per page",
                        "name": "page_size",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Field to sort by (default rating)",
                        "name": "sort_by",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order (ASC or DESC, default DESC)",
                        "name": "sort_order",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of movies",
                        "schema": {
                            "$ref": "#/definitions/controllers.ReadAllMoviesResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid page_size or page",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/movies/create": {
            "post": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Movies"
                ],
                "summary": "Create a new movie",
                "operationId": "create-movie",
                "parameters": [
                    {
                        "description": "Movie object to be created",
                        "name": "movie",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateMovieModel"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Movie created successfully",
                        "schema": {
                            "$ref": "#/definitions/controllers.CreateMovieResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request payload",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/movies/delete": {
            "delete": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Movies"
                ],
                "summary": "Delete a movie",
                "operationId": "delete-movie",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Movie ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Movie deleted successfully",
                        "schema": {
                            "$ref": "#/definitions/controllers.DeleteMovieResponse"
                        }
                    },
                    "400": {
                        "description": "Movie ID is required",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Failed to delete movie or its associations",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/movies/get": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Movies"
                ],
                "summary": "Get movie by ID",
                "operationId": "read-movie-by-id",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Movie ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Movie details",
                        "schema": {
                            "$ref": "#/definitions/controllers.ReadMovieResponse"
                        }
                    },
                    "400": {
                        "description": "Movie ID is required",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "404": {
                        "description": "Movie not found",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Failed to fetch movie",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/movies/patch": {
            "patch": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Movies"
                ],
                "summary": "Update an existing movie partially",
                "operationId": "patch-movie",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Movie ID",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "description": "Patch data for updating the movie",
                        "name": "patchData",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.CreateMovieModel"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Movie updated successfully",
                        "schema": {
                            "$ref": "#/definitions/controllers.PatchMovieResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request payload",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Failed to update movie or its associations",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/movies/update": {
            "put": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Movies"
                ],
                "summary": "Update an existing movie",
                "operationId": "update-movie",
                "parameters": [
                    {
                        "description": "Movie object to be updated",
                        "name": "movie",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.UpdateMovieModel"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Movie updated successfully",
                        "schema": {
                            "$ref": "#/definitions/controllers.UpdateMovieResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request payload",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Failed to update movie",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/search": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Search Movies"
                ],
                "summary": "Search for movies",
                "operationId": "search-movies",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Search query",
                        "name": "q",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Field to sort by (default rating)",
                        "name": "sort_by",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "Sort order (ASC or DESC, default DESC)",
                        "name": "sort_order",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "List of matching movies",
                        "schema": {
                            "$ref": "#/definitions/controllers.SearchMovieResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid search query",
                        "schema": {
                            "type": "string"
                        }
                    },
                    "500": {
                        "description": "Error encoding response",
                        "schema": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "/api/v1/users/login": {
            "post": {
                "description": "Log in a user with email and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Log in a user",
                "parameters": [
                    {
                        "description": "User credentials",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.LoginUserModel"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Logged In Successfully",
                        "schema": {
                            "$ref": "#/definitions/controllers.LoginResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request payload",
                        "schema": {
                            "$ref": "#/definitions/controllers.ErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Invalid email or password",
                        "schema": {
                            "$ref": "#/definitions/controllers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/controllers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/users/refresh": {
            "get": {
                "security": [
                    {
                        "BearerAuth": []
                    }
                ],
                "description": "Refresh JWT access and refresh tokens",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Refresh JWT tokens",
                "responses": {
                    "200": {
                        "description": "New access and refresh tokens",
                        "schema": {
                            "$ref": "#/definitions/controllers.RefreshTokenResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid or expired token",
                        "schema": {
                            "$ref": "#/definitions/controllers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/controllers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/api/v1/users/register": {
            "post": {
                "description": "Register a new user with email and password",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Authentication"
                ],
                "summary": "Register a new user",
                "parameters": [
                    {
                        "description": "User information",
                        "name": "request",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/models.RegisterUserModel"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "User Created Successfully",
                        "schema": {
                            "$ref": "#/definitions/controllers.CreateUserResponse"
                        }
                    },
                    "400": {
                        "description": "Invalid request payload",
                        "schema": {
                            "$ref": "#/definitions/controllers.ErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/controllers.ErrorResponse"
                        }
                    }
                }
            }
        },
        "/healthcheck": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Healthcheck"
                ],
                "summary": "Perform health check",
                "operationId": "health-check",
                "responses": {
                    "200": {
                        "description": "Health check response",
                        "schema": {
                            "$ref": "#/definitions/controllers.HealthCheckResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "controllers.CreateActorResponse": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "controllers.CreateMovieResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/models.Movie"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "controllers.CreateUserResponse": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            }
        },
        "controllers.DeleteActorResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "controllers.DeleteMovieResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "controllers.ErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        },
        "controllers.HealthCheckResponse": {
            "type": "object",
            "properties": {
                "author": {
                    "type": "string"
                },
                "current_time": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "controllers.LoginResponse": {
            "type": "object",
            "properties": {
                "access_token": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "refresh_token": {
                    "type": "string"
                },
                "role": {
                    "type": "string"
                }
            }
        },
        "controllers.PatchActorResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "controllers.PatchMovieResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "controllers.ReadActorResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/models.Actor"
                }
            }
        },
        "controllers.ReadAllActorResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Actor"
                    }
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "controllers.ReadAllMoviesResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Movie"
                    }
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "controllers.ReadMovieResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/models.Movie"
                }
            }
        },
        "controllers.RefreshTokenResponse": {
            "type": "object",
            "properties": {
                "refresh": {
                    "type": "string"
                },
                "token": {
                    "type": "string"
                }
            }
        },
        "controllers.SearchMovieResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Movie"
                    }
                }
            }
        },
        "controllers.UpdateActorResponse": {
            "type": "object",
            "properties": {
                "actor": {
                    "$ref": "#/definitions/models.Actor"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "controllers.UpdateMovieResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/models.Movie"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "models.Actor": {
            "type": "object",
            "required": [
                "birth_date",
                "first_name",
                "gender",
                "last_name"
            ],
            "properties": {
                "birth_date": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string",
                    "maxLength": 100
                },
                "gender": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "last_name": {
                    "type": "string",
                    "maxLength": 100
                },
                "movies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Movie"
                    }
                }
            }
        },
        "models.CreateActorModel": {
            "type": "object",
            "required": [
                "birth_date",
                "first_name",
                "gender",
                "last_name"
            ],
            "properties": {
                "birth_date": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string",
                    "maxLength": 100
                },
                "gender": {
                    "type": "string"
                },
                "last_name": {
                    "type": "string",
                    "maxLength": 100
                },
                "movies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Movie"
                    }
                }
            }
        },
        "models.CreateMovieModel": {
            "type": "object",
            "required": [
                "rating",
                "title"
            ],
            "properties": {
                "actors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Actor"
                    }
                },
                "description": {
                    "type": "string",
                    "maxLength": 1000
                },
                "genre": {
                    "type": "string"
                },
                "rating": {
                    "type": "number",
                    "maximum": 10,
                    "minimum": 0
                },
                "release_year": {
                    "type": "integer"
                },
                "title": {
                    "type": "string",
                    "maxLength": 150,
                    "minLength": 1
                }
            }
        },
        "models.LoginUserModel": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "minLength": 8
                }
            }
        },
        "models.Movie": {
            "type": "object",
            "required": [
                "genre",
                "rating",
                "release_year",
                "title"
            ],
            "properties": {
                "actors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Actor"
                    }
                },
                "description": {
                    "type": "string",
                    "maxLength": 1000,
                    "minLength": 1
                },
                "genre": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "rating": {
                    "type": "number",
                    "maximum": 10,
                    "minimum": 0
                },
                "release_year": {
                    "type": "integer"
                },
                "title": {
                    "type": "string",
                    "maxLength": 150,
                    "minLength": 1
                }
            }
        },
        "models.RegisterUserModel": {
            "type": "object",
            "required": [
                "email",
                "password"
            ],
            "properties": {
                "email": {
                    "type": "string"
                },
                "password": {
                    "type": "string",
                    "minLength": 8
                }
            }
        },
        "models.UpdateActorModel": {
            "type": "object",
            "required": [
                "birth_date",
                "first_name",
                "gender",
                "id",
                "last_name"
            ],
            "properties": {
                "birth_date": {
                    "type": "string"
                },
                "first_name": {
                    "type": "string",
                    "maxLength": 100
                },
                "gender": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "last_name": {
                    "type": "string",
                    "maxLength": 100
                },
                "movies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Movie"
                    }
                }
            }
        },
        "models.UpdateMovieModel": {
            "type": "object",
            "required": [
                "id",
                "rating",
                "title"
            ],
            "properties": {
                "actors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/models.Actor"
                    }
                },
                "description": {
                    "type": "string",
                    "maxLength": 1000
                },
                "genre": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "rating": {
                    "type": "number",
                    "maximum": 10,
                    "minimum": 0
                },
                "release_year": {
                    "type": "integer"
                },
                "title": {
                    "type": "string",
                    "maxLength": 150,
                    "minLength": 1
                }
            }
        }
    },
    "securityDefinitions": {
        "BearerAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Filmotek API",
        Description:      "Fimotek Api Docs",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package logger

import (
        "log"
        "os"
        "path/filepath"
)

var FileLogger *log.Logger

func SetupLogger() *log.Logger <span class="cov0" title="0">{
        relativeLogsDir := "./logs"
        absLogsDir, err := filepath.Abs(relativeLogsDir)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">if _, err := os.Stat(absLogsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.MkdirAll(absLogsDir, 0777); err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }
        <span class="cov0" title="0">logFilePath := filepath.Join(absLogsDir, "app.log")
        logFile, err := os.OpenFile(logFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">FileLogger = log.New(logFile, "SERVER_LOGS: ", log.LstdFlags)
        return FileLogger</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package prometheus

import "github.com/prometheus/client_golang/prometheus"

var (
        CreateMovieApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "create_movie_api_ping_counter",
                Help: "Number of pings made to the Create Movie API endpoint",
        })
        CreateActorApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "create_actor_api_ping_counter",
                Help: "Number of pings made to the Create Actor API endpoint",
        })
        RegisterApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "register_api_ping_counter",
                Help: "Number of pings made to the Register API endpoint",
        })
        LoginApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "login_api_ping_counter",
                Help: "Number of pings made to the Login API endpoint",
        })
        UpdateMovieApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "update_movie_api_ping_counter",
                Help: "Number of pings made to the Update Movie API endpoint",
        })
        UpdateActorApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "update_actor_api_ping_counter",
                Help: "Number of pings made to the Update Actor API endpoint",
        })
        PatchActorApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "patch_actor_api_ping_counter",
                Help: "Number of pings made to the Patch Actor API endpoint",
        })
        PatchMovieApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "patch_movie_api_ping_counter",
                Help: "Number of pings made to the Patch Movie API endpoint",
        })
        DeleteMovieApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "delete_movie_api_ping_counter",
                Help: "Number of pings made to the Delete Movie API endpoint",
        })
        DeleteActorApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "delete_actor_api_ping_counter",
                Help: "Number of pings made to the Delete Actor API endpoint",
        })
        ReadAllActorApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "read_all_actor_api_ping_counter",
                Help: "Number of pings made to the Read All Actor API endpoint",
        })
        ReadOneActorApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "read_one_actor_api_ping_counter",
                Help: "Number of pings made to the Read One Actor API endpoint",
        })
        ReadOneMovieApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "read_one_movie_api_ping_counter",
                Help: "Number of pings made to the Read One Movie API endpoint",
        })
        ReadAllMovieApiPingCounter = prometheus.NewCounter(prometheus.CounterOpts{
                Name: "read_all_movie_api_ping_counter",
                Help: "Number of pings made to the Read All Movie API endpoint",
        })
)

func Init() <span class="cov0" title="0">{
        prometheus.MustRegister(CreateMovieApiPingCounter)
        prometheus.MustRegister(CreateActorApiPingCounter)
        prometheus.MustRegister(RegisterApiPingCounter)
        prometheus.MustRegister(LoginApiPingCounter)
        prometheus.MustRegister(UpdateMovieApiPingCounter)
        prometheus.MustRegister(UpdateActorApiPingCounter)
        prometheus.MustRegister(PatchActorApiPingCounter)
        prometheus.MustRegister(PatchMovieApiPingCounter)
        prometheus.MustRegister(DeleteMovieApiPingCounter)
        prometheus.MustRegister(DeleteActorApiPingCounter)
        prometheus.MustRegister(ReadAllActorApiPingCounter)
        prometheus.MustRegister(ReadOneActorApiPingCounter)
        prometheus.MustRegister(ReadOneMovieApiPingCounter)
        prometheus.MustRegister(ReadAllMovieApiPingCounter)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package common

import (
        "encoding/json"
        "net/http"

        "github.com/charmbracelet/log"
        "github.com/go-playground/validator"
        "github.com/shuklarituparn/Filmoteka/api/models"
        "github.com/shuklarituparn/Filmoteka/internal/logger"
)

var file_logger = logger.SetupLogger()

func ErrorResponse(w http.ResponseWriter, status int, message string) <span class="cov0" title="0">{
        log.Error(message)
        file_logger.Println(message)
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        errorMsg := map[string]string{"error": message}
        err := json.NewEncoder(w).Encode(errorMsg)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Error encoding JSON:", err.Error())
                file_logger.Println("Error encoding JSON:", err.Error())
        }</span>
}

func ValidateAndRespond(w http.ResponseWriter, v interface{}) bool <span class="cov0" title="0">{
        validate := validator.New()
        err := validate.RegisterValidation("validDate", models.ValidDate)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusInternalServerError, "Server Error!")
        }</span>
        <span class="cov0" title="0">if err := validate.Struct(v); err != nil </span><span class="cov0" title="0">{
                errorsMap := make(map[string]interface{})
                for _, e := range err.(validator.ValidationErrors) </span><span class="cov0" title="0">{
                        errorsMap[e.Field()] = e.Tag()
                }</span>
                <span class="cov0" title="0">errJSON, _ := json.Marshal(errorsMap)
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusBadRequest)
                _, err := w.Write(errJSON)
                if err != nil </span><span class="cov0" title="0">{
                        ErrorResponse(w, http.StatusInternalServerError, "Server Error!")
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package hashing

import "golang.org/x/crypto/bcrypt"

func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), 14)
        return string(bytes), err
}</span>

func CheckPasswordHash(password string, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package jwt

import (
        "errors"
        "fmt"
        "os"
        "time"

        "github.com/golang-jwt/jwt"
)

var (
        ErrInvalidToken = errors.New("Invalid token")
)

type JWTClaims struct {
        Email string `json:"username"`
        Role  string `json:"role"`
        jwt.StandardClaims
}

func GetJWTToken(email string, role string, hour time.Duration) (string, error) <span class="cov0" title="0">{
        claims := JWTClaims{
                Email: email,
                Role:  role,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: time.Now().Add(time.Hour * hour).Unix(),
                        NotBefore: time.Now().Unix(),
                        IssuedAt:  time.Now().Unix(),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        signedToken, err := token.SignedString([]byte(os.Getenv("JWT_SECRET")))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create token")
        }</span>
        <span class="cov0" title="0">return signedToken, nil</span>
}

func VerifyToken(jwtToken string) (*JWTClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(jwtToken, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(os.Getenv("JWT_SECRET")), nil
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                var ve *jwt.ValidationError
                if errors.As(err, &amp;ve) </span><span class="cov0" title="0">{
                        if ve.Errors&amp;jwt.ValidationErrorMalformed != 0 </span><span class="cov0" title="0">{
                                return nil, ErrInvalidToken
                        }</span> else<span class="cov0" title="0"> if ve.Errors&amp;(jwt.ValidationErrorExpired|jwt.ValidationErrorNotValidYet) != 0 </span><span class="cov0" title="0">{
                                return nil, ErrInvalidToken
                        }</span> else<span class="cov0" title="0"> {
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrInvalidToken</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/charmbracelet/log"
        "github.com/shuklarituparn/Filmoteka/internal/logger"
        "github.com/shuklarituparn/Filmoteka/pkg/common"
        jwt "github.com/shuklarituparn/Filmoteka/pkg/jwt_token"
)

var file_logger = logger.SetupLogger()

func IsAdmin(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                log.Info("Request received:", r.Method, r.URL.Path)
                file_logger.Println("Request received:", r.Method, r.URL.Path)
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusUnauthorized, "Authorization header missing")
                        return
                }</span>
                <span class="cov0" title="0">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid authorization header format")
                        return
                }</span>
                <span class="cov0" title="0">token := tokenParts[1]
                claims, err := jwt.VerifyToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusForbidden, "Token Not Valid")
                        return
                }</span>
                <span class="cov0" title="0">if claims.Role != "ADMIN" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusForbidden, "You are not authorized to access this resource")
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package middleware

import (
        "net/http"
        "strings"

        "github.com/charmbracelet/log"
        "github.com/shuklarituparn/Filmoteka/pkg/common"
        jwt "github.com/shuklarituparn/Filmoteka/pkg/jwt_token"
)

func IsAuthenticated(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                log.Info("Request received:", r.Method, r.URL.Path)
                file_logger.Println("Request received:", r.Method, r.URL.Path)
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusUnauthorized, "Authorization header missing")
                        return
                }</span>
                <span class="cov0" title="0">tokenParts := strings.Split(authHeader, " ")
                if len(tokenParts) != 2 </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusBadRequest, "Invalid authorization header format")
                        return
                }</span>
                <span class="cov0" title="0">token := tokenParts[1]
                _, err := jwt.VerifyToken(token)
                if err != nil </span><span class="cov0" title="0">{
                        common.ErrorResponse(w, http.StatusForbidden, "Token Not Valid")
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
